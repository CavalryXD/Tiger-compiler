// This is automatically generated by the Tiger compiler.
// Do NOT modify!

// structures
struct BinaryTree
{
  struct BinaryTree_vtable *vptr;
};
struct BT
{
  struct BT_vtable *vptr;
};
struct Tree
{
  struct Tree_vtable *vptr;
  int left;
  int right;
  int key;
  int has_left;
  int has_right;
  int my_null;
};
// vtables structures
struct BinaryTree_vtable
{
};

struct BT_vtable
{
  int (*Start)();
};

struct Tree_vtable
{
  int (*Init)();
  int (*SetRight)();
  int (*SetLeft)();
  int (*GetRight)();
  int (*GetLeft)();
  int (*GetKey)();
  int (*SetKey)();
  int (*GetHas_Right)();
  int (*GetHas_Left)();
  int (*SetHas_Left)();
  int (*SetHas_Right)();
  int (*Compare)();
  int (*Insert)();
  int (*Delete)();
  int (*Remove)();
  int (*RemoveRight)();
  int (*RemoveLeft)();
  int (*Search)();
  int (*Print)();
  int (*RecPrint)();
};


// methods
int BT_Start(struct BT * this)
{
  int root;
  int ntb;
  int nti;
  struct Tree * x_1;
  struct Tree * x_2;
  struct Tree * x_3;
  struct Tree * x_4;
  struct Tree * x_5;
  struct Tree * x_6;
  struct Tree * x_7;
  struct Tree * x_8;
  struct Tree * x_9;
  struct Tree * x_10;
  struct Tree * x_11;
  struct Tree * x_12;
  struct Tree * x_13;
  struct Tree * x_14;
  struct Tree * x_15;
  struct Tree * x_16;
  struct Tree * x_17;
  struct Tree * x_18;
  struct Tree * x_19;

  root = ((struct Tree*)(Tiger_new (&Tree_vtable_, sizeof(struct Tree))));  ntb = (x_1=root, x_1->vptr->Init(x_1, 16));  ntb = (x_2=root, x_2->vptr->Print(x_2));  System_out_println (100000000);
  ntb = (x_3=root, x_3->vptr->Insert(x_3, 8));  ntb = (x_4=root, x_4->vptr->Print(x_4));  ntb = (x_5=root, x_5->vptr->Insert(x_5, 24));  ntb = (x_6=root, x_6->vptr->Insert(x_6, 4));  ntb = (x_7=root, x_7->vptr->Insert(x_7, 12));  ntb = (x_8=root, x_8->vptr->Insert(x_8, 20));  ntb = (x_9=root, x_9->vptr->Insert(x_9, 28));  ntb = (x_10=root, x_10->vptr->Insert(x_10, 14));  ntb = (x_11=root, x_11->vptr->Print(x_11));  System_out_println ((x_12=root, x_12->vptr->Search(x_12, 24)));
  System_out_println ((x_13=root, x_13->vptr->Search(x_13, 12)));
  System_out_println ((x_14=root, x_14->vptr->Search(x_14, 16)));
  System_out_println ((x_15=root, x_15->vptr->Search(x_15, 50)));
  System_out_println ((x_16=root, x_16->vptr->Search(x_16, 12)));
  ntb = (x_17=root, x_17->vptr->Delete(x_17, 12));  ntb = (x_18=root, x_18->vptr->Print(x_18));  System_out_println ((x_19=root, x_19->vptr->Search(x_19, 12)));
  return 0;
}
int Tree_Init(struct Tree * this, int v_key)
{

  key = v_key;  has_left = v_key;  has_right = v_key;  return v_key;
}
int Tree_SetRight(struct Tree * this, int rn)
{

  right = rn;  return rn;
}
int Tree_SetLeft(struct Tree * this, int ln)
{

  left = ln;  return ln;
}
int Tree_GetRight(struct Tree * this)
{

  return right;
}
int Tree_GetLeft(struct Tree * this)
{

  return left;
}
int Tree_GetKey(struct Tree * this)
{

  return key;
}
int Tree_SetKey(struct Tree * this, int v_key)
{

  key = v_key;  return v_key;
}
int Tree_GetHas_Right(struct Tree * this)
{

  return has_right;
}
int Tree_GetHas_Left(struct Tree * this)
{

  return has_left;
}
int Tree_SetHas_Left(struct Tree * this, int val)
{

  has_left = val;  return val;
}
int Tree_SetHas_Right(struct Tree * this, int val)
{

  has_right = val;  return val;
}
int Tree_Compare(struct Tree * this, int num1, int num2)
{
  int ntb;
  int nti;

  ntb = val;  nti = val;  if (num1 < num2)
    ntb = num1 < num2;
  else
    if (num1 < num2)
      ntb = num1 < num2;
    else
      ntb = num1 < num2;

  return ntb;
}
int Tree_Insert(struct Tree * this, int v_key)
{
  int new_node;
  int ntb;
  int cont;
  int key_aux;
  int current_node;
  struct Tree * x_20;

  new_node = ((struct Tree*)(Tiger_new (&Tree_vtable_, sizeof(struct Tree))));  ntb = (x_20=new_node, x_20->vptr->Init(x_20, v_key));  current_node = this;  cont = this;  cont = this;  return this;
}
int Tree_Delete(struct Tree * this, int v_key)
{
  int current_node;
  int parent_node;
  int cont;
  int found;
  int is_root;
  int key_aux;
  int ntb;

  current_node = this;  parent_node = this;  cont = this;  found = this;  is_root = this;  is_root = this;  return found;
}
int Tree_Remove(struct Tree * this, int p_node, int c_node)
{
  int ntb;
  int auxkey1;
  int auxkey2;
  struct Tree * x_21;
  struct Tree * x_22;
  struct Tree * x_23;
  struct Tree * x_24;

  if ((x_21=c_node, x_21->vptr->GetHas_Left(x_21)))
    ntb = (x_22=this, x_22->vptr->RemoveLeft(x_22, p_node, c_node));
  else
    if ((x_23=c_node, x_23->vptr->GetHas_Right(x_23)))
      ntb = (x_24=this, x_24->vptr->RemoveRight(x_24, p_node, c_node));
    else
      ntb = (x_24=this, x_24->vptr->RemoveRight(x_24, p_node, c_node));

  return (x_24=this, x_24->vptr->RemoveRight(x_24, p_node, c_node));
}
int Tree_RemoveRight(struct Tree * this, int p_node, int c_node)
{
  int ntb;
  struct Tree * x_25;
  struct Tree * x_26;

  if ((x_21=c_node, x_21->vptr->GetHas_Left(x_21)))
    ntb = (x_22=this, x_22->vptr->RemoveLeft(x_22, p_node, c_node));
  else
    if ((x_23=c_node, x_23->vptr->GetHas_Right(x_23)))
      ntb = (x_24=this, x_24->vptr->RemoveRight(x_24, p_node, c_node));
    else
      ntb = (x_24=this, x_24->vptr->RemoveRight(x_24, p_node, c_node));

  ntb = (x_25=p_node, x_25->vptr->SetRight(x_25, my_null));  ntb = (x_26=p_node, x_26->vptr->SetHas_Right(x_26, p_node));  return (x_26=p_node, x_26->vptr->SetHas_Right(x_26, p_node));
}
int Tree_RemoveLeft(struct Tree * this, int p_node, int c_node)
{
  int ntb;
  struct Tree * x_27;
  struct Tree * x_28;

  ntb = (x_26=p_node, x_26->vptr->SetHas_Right(x_26, p_node));  ntb = (x_27=p_node, x_27->vptr->SetLeft(x_27, my_null));  ntb = (x_28=p_node, x_28->vptr->SetHas_Left(x_28, p_node));  return (x_28=p_node, x_28->vptr->SetHas_Left(x_28, p_node));
}
int Tree_Search(struct Tree * this, int v_key)
{
  int cont;
  int ifound;
  int current_node;
  int key_aux;

  current_node = this;  cont = this;  ifound = 0;  ifound = 0;  return ifound;
}
int Tree_Print(struct Tree * this)
{
  int current_node;
  int ntb;
  struct Tree * x_29;

  current_node = this;  ntb = (x_29=this, x_29->vptr->RecPrint(x_29, current_node));  return (x_29=this, x_29->vptr->RecPrint(x_29, current_node));
}
int Tree_RecPrint(struct Tree * this, int node)
{
  int ntb;
  struct Tree * x_30;
  struct Tree * x_31;
  struct Tree * x_32;

  if ((x_30=node, x_30->vptr->GetHas_Left(x_30)))
    ntb = (x_29=this, x_29->vptr->RecPrint(x_29, current_node));
  else
    ntb = (x_30=node, x_30->vptr->GetHas_Left(x_30));
  System_out_println ((x_31=node, x_31->vptr->GetKey(x_31)));
  if ((x_32=node, x_32->vptr->GetHas_Right(x_32)))
    System_out_println ((x_31=node, x_31->vptr->GetKey(x_31)));

  else
    ntb = (x_32=node, x_32->vptr->GetHas_Right(x_32));
  return (x_32=node, x_32->vptr->GetHas_Right(x_32));
}

// vtables
struct BinaryTree_vtable BinaryTree_vtable_ = 
{
};

struct BT_vtable BT_vtable_ = 
{
  BT_Start,
};

struct Tree_vtable Tree_vtable_ = 
{
  Tree_Init,
  Tree_SetRight,
  Tree_SetLeft,
  Tree_GetRight,
  Tree_GetLeft,
  Tree_GetKey,
  Tree_SetKey,
  Tree_GetHas_Right,
  Tree_GetHas_Left,
  Tree_SetHas_Left,
  Tree_SetHas_Right,
  Tree_Compare,
  Tree_Insert,
  Tree_Delete,
  Tree_Remove,
  Tree_RemoveRight,
  Tree_RemoveLeft,
  Tree_Search,
  Tree_Print,
  Tree_RecPrint,
};


// main method
int Tiger_main ()
{
  struct BT * x_0;
  System_out_println ((x_0=((struct BT*)(Tiger_new (&BT_vtable_, sizeof(struct BT)))), x_0->vptr->Start(x_0)));
}




